--------------------------------------------------------------------------------
-- SETUP -----------------------------------------------------------------------

@set XP Request Validation System <xrvs>=INHERIT SAFE

@rxlevel XP Request Validation System <xrvs>=All
@txlevel XP Request Validation System <xrvs>=All

&D.JOBS-SYSTEM XP Request Validation System <xrvs>=#2530
&D.JOBS-DATABASE XP Request Validation System <xrvs>=#2564

@@ For ajobs' job searches, %0: dbref of player to search
&D.RECENT.XP-JOBS XP Request Validation System <xrvs>=
	bucket=XP & source=%0 & opened<=7d

@@ Regmatch for splitting up: +xpreq <foo>
&D.REGMATCH.XPREQ XP Request Validation System <xrvs>=
	(.*?)( to (.*?))? for (.*)

@parent XP Request Validation System <xrvs>=#2833
&PREFIX.DISPLAY XP Request Validation System <xrvs>=display.

@Desc XP Request Validation System <xrvs>=This object does some minimal processing on xp spend requests before adding them to the player's most recent XP bucket job, unless that job was opened more than a week ago then it creates a new one. ( ex %!/d.recent.xp-jobs )%r%rSome trait classes require values, some don't. Those that don't (besides specialties, which are handled differently) are listed here: ex %!/d.no-value.classes %r%rWarning: Some of this is working in spite of using registers in @trigger calls. I'm not cleaning it up, but someone in the future may want to. - Theno


--------------------------------------------------------------------------------
-- TRIGGER: PROCESS NORMAL TRAITS ----------------------------------------------

0: enactor (%#)
1: to-value
2: notes
3: trait category
4: stat/trait with underscores
5: type (instance)
6: unadjusted cost
7: adjusted cost
8: 1 if unapproved

f: full stat name (for partial-name matching)
u: templates that are allowed access
i: temp register, via u( f.statget )
t: type / instance (%5), or replaced via u( f.statget )
z: player's current value for trait, via u( f.statget )
v: costs allowed for this trait
d: display
j: most recent active xp job
b: xp bucket

--

&TRIG.PROCESS.NORMAL XP Request Validation System <xrvs>=
	think 
		full stat: [setr( f, statfull( %3, %4 ))]; 

@@ .. validate trait category and trait 

	@assert t( statnum( %3, %4 ))={ 
		@pemit %0=I can't find the [lcstr( %3 )] '[edit( %q4, _, %b )]'. 
	}; 

	@assert isrepeat( %3, %4 )={ 
		@pemit %0=[titlestr( %3 )]: [mall( %3, %4 )] 
	}; 

	@assert 
		cor( 
			match( setr( u, default( #2681/access-%4, all )), all ), 
			strmatch( template( %0 ), %qu )
		)={ 
			@pemit %0=The trait '%qf' is only for the template(s) 
			[itemize( %qu )]. 
	}; 

@@ .. get stat's current value

	think 
		u( f.statget, 
			if( not( %qf ), global, normal), 
			%0, %3, setr( t, %5 ), %qf 
		); 
	
	@assert 
		if( 
			t( match( v( d.no-value.classes ), %3 )), 
			1, 
			or( 
				t( match( cat( setr( v, u( f.list.costs, %qf )), 0 ), %1 )), 
				cand( strmatch( %qv, ), isint( %1 ), gte( %1, 0 ))
			)
		)={ 
			@pemit %0=
				if( strmatch( %qv, ), 
					I was expecting the new value to be a positive integer., 
					I was expecting a new value of: [itemize( %qv, , or )] 
				) 
		}; 

	@assert 
		if( 
			t( match( v( d.no-value.classes ), %3 )), 
			strmatch( %1, ), 
			1 
		)={ 
			@pemit %0=[capstr( %3 )]s cannot be set to a value. 
		}; 

	@assert 
		cor( gt( %1, %qz ), strmatch( %1, ))={ 
			@pemit %0=The trait's new value of '%1' must be higher than its 
			current value of '%qz'. 
	}; 

	@assert 
		cor( isint( %6 ), gt( %6, 0 ))={ 
			@pemit %0=Unadjusted costs must be set to a positive integer value. 
	}; 

	@assert cor( not( t( %7 )), cand( isint( %7 ), gt( %7, 0 )))={ 
		@pemit %0=Modified costs must be set to a positive integer value. 
	}; 

	@assert cor( not( t( %7 )), t( %2 ))={ 
		@pemit %0=If you have a modified xp cost then you must include notes as 
		to why. 
	}; 

	@@ <<<--- display: 0: <3/qc/category>, 1: <qf/full stat>, 2: <qt/5/type>, 3: <6/qx/xp_cost>, 4: <7/qm/modified_cost>, 5: <qz/current_value>, 6: <1/4/new_value>, 7: <2/9/notes>, 8: <8/qa/in_chargen?> 9: <name(%0)/name of target>--->>>; 

	@pemit %0=
		[wheader( Buying: [u( display.job-title, %3, %qf, %qt, %qz, %1 )] )]%r
		[setr( d, 
			u( display.xp-spend.[if( t( %qf ), normal, general )], 
				%3, 
				%qf, 
				%qt, 
				%6, 
				%7, 
				%qz, 
				%1, 
				%2, 
				%8, 
				name( %0 )
			)
		)]%r
		[wfooter( )]; 

	think 
		most recent active xp job: 
			[setr( j, last( u( f.recent.xp-jobs, %0 )))]%r
		xp bucket: [setr( b, u( [v(d.jobs-database)]/FN_FIND-BUCKET, XP ))]; 

	@if t( %qj )={ 
		@trigger %!/trig.job.add=%0, %qj, %r%qd; 
	}, { 
		@trigger %!/trig.job.create=
			%0, 
			u( display.job-title, %3, %qf, %qt, %qz, %1 ), 
			%r%qd; 
	};



--------------------------------------------------------------------------------
-- DISPLAY: NORMAL XP SPEND ----------------------------------------------------

0: trait type (merit, specialty, etc.)
1: attribtue_name (trait)
2: instance (french, latin, etc.)
3: cost (final?)
4: cost (initial?)
5: 'from' value
6: 'to' value
7: 

--

&DISPLAY.XP-SPEND.NORMAL XP Request Validation System <xrvs>=

@@ >> player portion
	%r
	[ucstr( 
		strcat( 
			setr( e, edit( %1, _, %b )), 
			if( t( %2 ), 
				[if( strmatch( %0, specialty ), ., : )]
				[setr( t, edit( %2, _, %b ))] 
			)
		)
	)] ([lcstr( %0 )])
	[if( strlen( %6 ), setr( v, %b%5 > %6 ), setr( v, ))]%r

	XP Cost: %3[if( t( %4 ), %b%(%4%) )]
	[if( t( %7 ), %r--%r%7 )]%r%r

@@ >> staff portion
	[divider( staff commands )]%r%r

@@ .. stat-setting
	[strcat( 
		sheet/set %9/%0=, 
		if( cand( eq( %6, 0 ), strlen( %6 )), !), 
		lcstr( %1 ), 
		case( 1, 
			t( %6 ), :%6, 
			cand( eq( %6, 0 ), strlen( %6 )), :%5 
		), 
		if( t( %2 ), 
			if( strmatch( %0, specialty ), 
				:%2, 
				/%2 
			)
		), 
@@ .. .. merits need manually unset, because main stat code
		if( 
			cand( strmatch( %0, merit ), gt( %5, 0 ), gt( %6, 0 )), 
			strcat( 
				%rsheet/set %9/%0=!, 
				lcstr( %1 ), 
				:%5, 
				if( t( %2 ), /%2 ) 
			)
		)
	)]%r

@@ .. xp-logging
	[strcat( 
		+xp/spend %9=, 
		if( t( %4 ), %4, %3 ), 
		:, 
		if( %8, CHARGEN:%b ), 
		%qe, 
		if( t( %2 ), if( strmatch( %0, specialty ), .%qt, %b(%qt) )), 
		%qv 
	)]%r


--------------------------------------------------------------------------------
-- DISPLAY: SPEND 'GENERAL' TRAIT ----------------------------------------------

&DISPLAY.XP-SPEND.GENERAL XP Request Validation System <xrvs>=%r[ucstr( setr( e, edit( %0, _, %b )))] (general) %5 > %6%rXP Cost: %3[if( t( %4 ), %b%(%4%) )][if( t( %7 ), %r--%r%7)]%r%r[divider(staff commands)]%r%r[strcat(sheet/set %9/%0=, %6, if( t( %2 ), /%2 ))]%r[strcat(+xp/spend %9=, if( t( %4 ), %4, %3 ), :, if( %8, CHARGEN:%b ), [titlestr( %qe )], %b, %5 > %6)]%r


--------------------------------------------------------------------------------
-- GET CURRENT STAT: NORMAL ----------------------------------------------------

@@ qf: Attribute name from further up the chain -- critical!

&F.STATGET.NORMAL XP Request Validation System <xrvs>=
	result from stat(): [setr( i, stat( %0, %qf[if( t( %2 ), ::%2 )] ))]


--------------------------------------------------------------------------------
-- GET CURRENT STAT: GLOBAL ----------------------------------------------------

&F.STATGET.GLOBAL XP Request Validation System <xrvs>=
	result from stat(): [setr( i, stat( %0, %1 ))]


--------------------------------------------------------------------------------
-- GET CURRENT STAT: SPECIALTY -------------------------------------------------

&F.STATGET.SPECIALTY XP Request Validation System <xrvs>=
	@@( folded into trig.process.specialty )


--------------------------------------------------------------------------------
-- GET CURRENT STAT ------------------------------------------------------------

0: trait is 'normal', 'global', or 'specialty'
1: dbref of target
2: trait category
3: trait type / instance
4: trait name

i: temp register
z: player's current value

--

&F.STATGET XP Request Validation System <xrvs>=
	[u( f.statget.%0, %1, %2, %3, %4 )] %r
	type: 
		[if( 
			t( extract( %qi, 3, 1, : )), 
			setr( t, extract( %qi, 3, 1, : ))
		)] %r
	current value: [setr( z, if( t( setr( z, extract( %qi, 2, 1, : ))), %qz, 0 ))]


--------------------------------------------------------------------------------
-- TRIGGER: ADD TO JOB ---------------------------------------------------------

&TRIG.JOB.ADD XP Request Validation System <xrvs>=
	@trigger [get( v( d.jobs-system )/va )]/TRIG_MYADD=
		%1, 
		stripansi( %2 ), 
		%0, 
		ADD; 

	@trigger [get( v( d.jobs-system )/va )]/TRIG_BROADCAST=
		%1, 
		%0, 
		ADD; 

	@if not( strmatch( get( %1/title ), *(and more) ))={ 
		&title %1=[get( %1/title )] (and more) 
	};


--------------------------------------------------------------------------------
-- TRIGGER: CREATE NEW JOB -----------------------------------------------------

&TRIG.JOB.CREATE XP Request Validation System <xrvs>=@trigger [setr( a, get( setr( c, v( d.jobs-system ))/va ))]/TRIG_CREATE=%0, u( %qa/FN_FIND-BUCKET, XP ), 2, u( %qa/FN_STRTRUNC, %1, 30 ), u( %qa/FN_STRTRUNC, trim( stripansi( %2 )), get( %qa/BUFFER )), , u( %qc/get_sphere_jgroup, %0 ), 2;

--

--

&F.RECENT.XP-JOBS XP Request Validation System <xrvs>=u( [v( d.jobs-system )]/fn_jobs/select, u( d.recent.xp-jobs, %0 ))

--

&D.NO-VALUE.CLASSES XP Request Validation System <xrvs>=benediction ceremonies devotion elixir gift goblin numina rite ritual rote tactic theban vestment

--

&DISPLAY.JOB-TITLE XP Request Validation System <xrvs>=[titlestr( edit( if( t( %1 ), %1, %0 ), _, %b ))][if( t( %2 ), if( strmatch( %0, specialty ), .[titlestr( edit( %2, _, %b ))], %b([titlestr( edit( %2, _, %b ))])))][if( cor( t( %3 ), t( %4 )), :%b%3 > %4 )]

--

&CMD.SWITCH.JOB XP Request Validation System <xrvs>=think title: [setr( t, stripansi( before( secure( %1 ), = )))]%rdisplay: [setr( d, stripansi( after( secure( %1 ), = )))]; 

@pemit %0=You have requested '%qt' to the XP bucket for staff. Please allow for some time to process it.; 

@trigger %!/trig.job.create=%0, %qt, %r%qd ;


--------------------------------------------------------------------------------
-- XP COSTS FOR VARIOUS THINGS -------------------------------------------------

@@ by 'costs' we mean values that you can set it to, not xp costs

&F.LIST.COSTS XP Request Validation System <xrvs>=localize( 
	case( 1, 
		isint( setr( i, get( #2672/COST-%0 ))), 
		%qi, 

		strmatch( %qi, ?-* ), 
		lnum( before( %qi, - ), after( %qi, - )), 

		%qi 
	)
)


--------------------------------------------------------------------------------
-- COMMAND: XP REQUEST ---------------------------------------------------------

0: everything

q0: regex on %0
q1: category/trait
q2: to value
q3: value
q4: everything else

c: trait category
t: type (instance)
s: trait name (stat)
x: unadjusted cost
m: adjusted cost
n: notes
a: 1 if unapproved
i: all matching trait categories (or error)
e: stat with underscores

--

&CMD.XP_SPEND XP Request Validation System <xrvs>=$+xpreq *:
	think 
		matching: [regmatchi(%0, v( d.regmatch.xpreq ), 0 1 2 3 4 )]%r
		category: [setr( c, trim( first( %q1, / )))] %r
		stat: [setr( s, trim( before( rest( %q1, / ), : )))] %r
		type: [setr( t, titlestr( trim( rest( %q1, : ))))] %r
		to value: %q3 %r
		unadjusted cost: [setr( x, 
			trim( before( before( before( %q4, = ), / ), xp ))
		)]%r
		adjusted cost: [setr( m, 
			trim( before( after( before( %q4, = ), / ), xp ))
		)]%r
		notes: [setr( n, trim( after( %0, = )))]; 

	@assert cor( isapproved( %# ), setr( a, isapproved( %#, unapproved )))={ 
		@pemit %#=Approved or unapproved players only. 
	}; 

	@assert t( statnum( sheetset, %qc ))={ 
		@pemit %#=I can't find sheet category '%qc'. 
	}; 

	@assert eq( words( rest( setr( i, mall( sheetset, %qc )), : )), 1 )={ 
		@pemit %#=Category: %qi 
	}; 

	think 
		category alias: [setr( c, 
			case( 
				setr( c, trim( rest( %qi, : ))), 
				respect, renown, 
				contracts, contract, 
				ceremonies, ceremonies, 
				%qc 
			)
		)] %r
		stat_with_underscores: [setr( e, edit( %qs, %b, _ ))]; 

	@trigger %!/trig.process.
		[if( strmatch( %qc, specialty ), specialty, normal )]=
		%#, 
		%q3, 
		%qn, 
		%qc, 
		%qe, 
		%qt, 
		%qx, 
		%qm, 
		%qa;

--

	0: enactor (%#)
	1: to-value
	2: notes
	3: trait category
	4: stat with underscores
	5: type (instance)
	6: unadjusted cost
	7: adjusted cost
	8: unapproved?

--------------------------------------------------------------------------------
-- COMMAND: XP REQUEST WITH SWITCH ---------------------------------------------

&CMD.XP_SWITCH XP Request Validation System <xrvs>=$^\+xpreq/([^ ]*)?([\s\S]*)?$:@assert cor( isapproved( %# ), setr( a, isapproved( %#, unapproved )))={ @pemit %#=Approved or unapproved players only. }; 

@assert t( setr( s, lattr( %!/cmd.switch.%1* )))={ @pemit %#=No such switch. }; 

think switch: [setr( s, if( t( match( %qs, cmd.switch.%1 )), cmd.switch.%1, %qs ))]; 

@assert eq( words( %qs ), 1 )={ @pemit %#=Matches too many switches. }; 

@trigger %!/%qs=%#, trim( %2 );

--

@set XP Request Validation System <xrvs>/CMD.XP_SWITCH = regexp


--------------------------------------------------------------------------------
-- TRIGGER: PROCESS A SPECIALTY ------------------------------------------------

&TRIG.PROCESS.SPECIALTY XP Request Validation System <xrvs>=
	think 
		full stat: [setr( f, statfull( skill, %4 ))] %r
		specialty: [setr( t, iter( %5, titlestr( %i0 ), _, _))] %r
		matching specialties: 
			[setr( z, 
				grab( 
					get( %0/_specialties ), 
					[statnum( skill, %qf )]:%qt 
				)
			)]; 

	@assert cand( t( %4 )), t( %5 ))={ 
		@pemit %0=You must give me both a skill and a specialty. 
	}; 

	@assert t( %qf )={ 
		@pemit %0=Specialties can only be added to skills. 
	}; 

	@assert not( %1 )={ 
		@pemit %0=Specialties cannot be set to a value. 
	}; 

	@break t( %qz )={ 
		@pemit %0=You already have that specialty. 
	}; 

	@@ <<<--- Also in trig.process.normal --->>>; 

	@assert cand( isint( %6 ), gt( %6, 0 ))={ 
		@pemit %0=Unadjusted costs must be set to a positive integer value. 
	}; 

	@assert eq( %6, 3 )={ 
		@pemit %0=I was expecting the specialty to be 3 xp. 
	}; 

	@assert cor( not( t( %7 )), cand( isint( %7 ), gt( %7, 0 )))={ @pemit %0=Modified costs must be set to a positive integer value. }; 

	@assert cor( not( t( %7 )), t( %2 ))={ 
		@pemit %0=If you have a modified xp cost then you must include notes as to why. 
	}; 

	@@ <<<--- display: 0: specialty1: <qf/full stat>, 2: <qt/type>, 3: <6/qx/xp_cost>, 4: <7/qm/modified_cost>, 5: <from_value:null>, 6: <to_value:null>, 7: <2/9/notes>, 8: <8/qa/in_chargen?> 9: <name(%0)/name of target>--->>>; 

	@pemit %0=
		[wheader( Buying: [u( display.job-title, specialty, %qf, %qt, , )] )]%r
		[setr(d, 
			u( display.xp-spend.normal, 
				specialty, 
				%qf, 
				%qt, 
				%6, 
				%7, 
				, 
				, 
				%2, 
				%8, 
				name( %0 )
			)
		)]%r
		[wfooter( )]; 

	think 
		most recent active xp job: 
			[setr( j, last( u( f.recent.xp-jobs, %0 )))] %r
		xp bucket: [setr( b, u( [v(d.jobs-database)]/FN_FIND-BUCKET, XP ))]; 

	@if t( %qj )={ 
		@trigger %!/trig.job.add=
			%0, 
			%qj, 
			%r%qd; 
	}, { 
		@trigger %!/trig.job.create=
			%0, 
			u( display.job-title, specialty, %qf, %qt, , ), 
			%r%qd; 
	};



================================================================================
== THE STAT() FUNCTION =========================================================

Here in case it doesn't grab a different trait category

--

&FP_STAT #978=
	[objeval( %@, localize( 
		[setq( g, )]
		[setq( n, edit( first( %1, : ), %b, _ ))]
		[setq( g, 
			iter( u( #4734/f.iterlist, sphere( %0 )), 
				if( 
					t( setr( z, grab( u( #89/%i0 ), %qn* ))), 
					%i0 %qz 
				), 
				, | 
			)
		)]
		[if( 
			setr( z, grab( %qg, LIST_* %qn, | )), 
			setq( g, %qz ), 
			setq( g, grab( %qg, LIST_* %qn*, | ))
		)]
		[setq( 0, rest( %qg ))]
		[setq( 1, extract( %1, 2, 1, : ))]
		[setq( 2, extract( %1, 3, 1, : ))]
		[if( 
			and( 
				t( setr( x, u( #4734/f.stat, %0, %q0 ))), 
				strmatch( %qx, %q0* %q1* )
			), 
			edit( %qx, %b, : ), 

			if( 
				t( setr( y, first( lattr( %0/_%1* )))), 
				[titlestr( edit( %qy, _, ))]:
				[getattr( %0, %qy )], 

				switch( 
					t( setr( w, lcstr( rest( first( %qg ), _ )))), 
					0, 
					#-1, 
					if( 
						t( setr( c, 
							case( 1, 
@@ .. traits in these catagories are stored: <name>~<type/instance>~<value>
								t( match( merit|favor|aspects, %qw*, | )), 
								edit( 
									if( 
										t( setr( v, 
											grab( 
												getattr( %0, _%qw ), 
												%q0*~%q1*~%q2*, | 
											)
										)), 
										%qv, 
										grab( 
											getattr( %0, _%qws ), 
											%q0*~%q1*~%q2*, | )
										), 
									~, : 
								), 

@@ .. traits in these catagories are stored: <name>:<value>
								t( match( contract|discipline, %qw*, | )), 
								grab( 
									getattr( 
										%0, 
										first( sort( cat( 
											lattr( %0/_%qw ), 
											lattr( %0/_%qws )
										)))
									), 
									%q0*:%q2* 
								), 

								grab( getattr( %0, _%qw ), %q0*:%q1* )
							)
						)), 
						%qc, 
						#-1 
					)
				)
			)
		)]
	 ))]

